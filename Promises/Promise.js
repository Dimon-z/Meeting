/* Сейчас я приведу один пример и вы его запомните надолго. 
Итак, у нас есть HTML-страничка, а в ней вот такой скрипт: */

const gopniks = [
  { name: 'hustla1', say: 'Wuzup yo?' },
  { name: 'OG', say: 'Gimme yur money man' }
];

function gopnikSay() {
  setTimeout(() => {
    let output = '';
    gopniks.forEach(gopnik => {
      output += `<li>${gopnik.say}</li>`;
    });
   document.body.innerHTML = output;
  }, 1000)
}

function addGopnik(man) {
  setTimeout(() => {
    gopniks.push(man);
  }, 2000)
}

gopnikSay();
addGopnik({ name: 'SupaLooter', say: 'Gopnik Lies on Mattrass' });


/* Что тут происходит? У нас есть массив с двумя элементами- это два объекта с несколькими свойствами. 
Далее идёт функция, которая пробегается по этому массиву, 
вытаскивает из объектов фразы и через 1 секунду выводит их в html-страничку. 
Затем объявляется функция addGopnik, добавляющая третий подобный объект в массив спустя 2 секунды. 
Внизу обе функции вызываются, последней собственно и передается третий объект.
Но если мы посмотрим на наш документ, то спустя секунду увидим такую картину:

* Wuzup yo?
* Gimme yur money man

А где третий объект, почему фраза из него не отобразилась?
Просто к моменту, когда третий объект добавился в наш массив,
страничка уже секунду как отрисовалась, поэтому он пролетел мимо кассы. 
Мы можем исправить ситуацию, если в setTimeout второй функции поставить не 2000, а например 500. 
Тогда он успеет добавиться и спустя секунду выведутся уже все три фразы. Но это ведь лажа какая-то.
Как нам сделать, чтобы третий объект сам добавлялся, когда понадобится и не крутить внутри ничего?
Конечно с помощью колбеков. Что это вообще за ботва? Колбек- это функция A,
переданная другой функции B в виде её параметра и вызванная внутри B после каких-то манипуляций. 
Определение выглядит уродско, но сейчас на примере станет понятнее. Я чуть-чуть изменю вторую функцию и её вызов. Хоба: */

function addGopnik(man, cb) {
  setTimeout(() => {
    gopniks.push(man);
    cb();
  }, 2000)
}

addGopnik({ name: 'SupaLooter', say: 'Gopnik Lies on Mattrass' }, gopnikSay)


/* Обратите внимание, что функция передается в виде ссылки, без скобок на конце. 
Так работает колбек, все три объекта вывелись. И всё вроде норм, но что если мы захотим добавить четвертый объект спустя 5 секунд? 
Дописывать ещё один колбек? А куда, внутрь уже существующего или сразу за ним? 
Всего два колбека, а уже возникают некие проблемы, но это ещё полбеды. Как обрабатывать ошибки, которые будут сыпаться отовсюду?
В итоге мы придём к куче скобок, if-else и всю эту кучу дерьма придется кому-то разгребать и поддерживать в рабочем состоянии.
И в nodejs так раньше и было (а в старом коде и сейчас есть), пока не появились промисы.
Уберем колбек и добавим промис: */

function addGopnik(man) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      gopniks.push(man);
      resolve();
    }, 2000)
  })
}

addGopnik({ name: 'SupaLooter', say: 'Gopnik Lies on Mattrass' }).then(gopnikSay);

/* И чё? Кода меньше ни фига не стало, зачем же мы эту байду переписывали на промисы? 
Да, здесь эффект не заметен, потому что колбеков мало, но когда их много (колбек-хелл) то промисы здорово облегчают код. 
Уже не возникает вопрос, куда воткнуть колбек. Вместо "ада колбеков" получается .then().then().then() А обработка ошибок?
 Пишем .catch() в конце и всего делов. Читабельность кода можно ещё улучшить, изменив синтаксис на async- await. 
 Он ни фига особо не делает, только придает асинхронному коду вид синхронного. То есть убирает цепочки then(),
  но добавляет "const" и точки с запятой на конце, как мы привыкли. */